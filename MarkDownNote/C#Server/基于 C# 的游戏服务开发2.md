本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/16D1dT6pwNmjCL3GqoEwzA)

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0aVnAhURoJcLfzJmw6zKeicKWh6INBPoOz4qIZA6lLDKpeXZiaia1oicomu4t79KPkSIWXXmKTnUHxsDQ/640?wx_fmt=png)

  

> 上文中你知道, 阻塞是个什么样的东西, 就是没有客户端来连接, 服务器就卡在那里不继续向下运行了, 其实客户端也一样, 也是一个阻塞程序. 说的更精确一点, 他们都是同步 socket 程序, 还有, 服务器只能连接一个客户端, 你可以将上文中做的客户端打成 exe 的包, 同时打开, 这个时候服务器只能回应一个客户端, 就是谁先连接到, 就回应谁, 要想回应第二个客户端, 那么得把第一个客户端关掉. 但是这个不代表同步 socket 程序就不能连接多个客户端, 只要新开线程就可以了, 假如这台服务器要服务 1 万个玩家, 那么要用同步 socket 方法的话, 那么它就要开 1 万个线程, 也可以达到效果, 但是仔细想想, 1 万个线程, 想想就觉得可怕. 所以游戏服务器首先不考虑的就是同步 socket 的方式了.
> 
> * * *
> 
> 到这里, 也许你可能会认为, 同步程序没有什么意义, 但是存在即合理, 同步程序在这里不适合做游戏服务器不代表它在其他的方面就没有用处, 比如, 我们在用远程桌面的时候, 就是使用同步程序, 比如 A 电脑控制了 B 电脑, 那么 B 电脑一定是等待 A 电脑的指令过来了之后再做处理的, 如果不这样做的话, 遇到弱网络环境, 一定会出乱子.  

  

2 个问题需要解决

  

第一个, 把客户端和服务器的 同步 socket 改成异步 socket

第二个, 要多客户端同时连接服务器.

 

![](https://mmbiz.qpic.cn/mmbiz_gif/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0gaQUZadZZmNYMKCLcxbfgkTD9BjVic2meN0fn1zpbic8Ed2fDd8wPialw/640?wx_fmt=gif)

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0xdCia1SPFolCMuUECusKsibCzPop89EwTcwiaTbNc2wywUXpEQjuMjn0Q/640?wx_fmt=png)

异步模式的客户端

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0sEZr4OfYSiaicJ7relzafHEb9GVp3eWeC9l9ViaJNEaiaphVvQgqOjGXibA/640?wx_fmt=png)

异步 socket 程序与同步 socket 的区别有一点就在于, 虽然客户端没有连接, 但是客户端照常运行. 并且里面还带有回调函数参数, 所以上篇文章中的 socket._Connect_(iPEP); 这个阻塞的方法就不能用了, 得用一个新的方法了. 其实在每一个同步方法 (API) 中都对应着 2 个异步的方法, 比如上面的这一句 Connect 就对应着异步中的 BeginConnect 和 EndConnect.

我们先来看 BeginConnect 的函数原型:  

```
public IAsyncResult BeginConnect(IPAddress[] addresses, int port,
 AsyncCallback requestCallback, object state);

public IAsyncResult BeginConnect(IPAddress address, int port,
 AsyncCallback requestCallback, object state);

public IAsyncResult BeginConnect(string host, int port,
 AsyncCallback requestCallback, object state);

public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback
 callback, object state);


```

我们来看最后的一个函数原型, 我们用的就是最后一个, 里面有 3 个参数:

<table cellspacing="0"><tbody><tr><td width="105" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext; border-style: solid; border-width: 1px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p>参数</p></td><td width="464" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext windowtext windowtext currentcolor; border-style: solid solid solid none; border-width: 1px 1px 1px medium; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p>说明</p></td></tr><tr><td width="105" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">remoteEP</span></p></td><td width="464" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p>这里储存着远程服务器的 ip 地址和端口</p></td></tr><tr><td width="105" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">callback</span></p></td><td width="464" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p>一个 AsyncCallback 委托, 即回调函数, 也可以称之为异步回调, 那么这个回调的函数格式必须是: public &nbsp;void</p><p>ConnectCallback (IAsyncResult ar) &nbsp;</p></td></tr><tr><td width="105" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">state</span></p></td><td width="464" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p>一个用户定义的对象, 可以包含连接操作的相关信息, 此对象会传给回调函数.</p></td></tr></tbody></table>

当然第一个参数就是服务器的 IP 地址和端口, 从函数原型来看, 也是可以连接多个服务器的. 但是本系列中并不涉及.

Callback 回调函数 什么是回调函数呢? 通俗的来说假如有 A 与 B 两个函数, B 函数中有着对 A 函数的委托, 当 B 中满足了某个条件之后, 就开始调用 A.

这就是回调函数. 但是这个回调函数中呢, 又有一个 _IAsyncResult_ .

也许你会好奇这个在回调函数中的 _IAsyncResult_ 到底是什么呢?, 有什么作用呢? 其实 IAsyncResult 本质上是个接口，里面有几个属性用来查看可以查看异步操作的状态, 因为是异步回调嘛, 所以在这个方法中, 函数尝试这去连接服务器的时候 , 要知道它什么时候连接上了. 下面是它的几个方法.

*   AsyncState 获取用户定义的对象，它限定或包含关于异步操作的信息。
    
*   AsyncWaitHandle 获取用于等待异步操作完成的 WaitHandle。
    
*   CompletedSynchronously 获取异步操作是否同步完成的指示。
    
*   IsCompleted 获取异步操作是否已完成的指示。
    

我们用到的就是 AsyncState 获取用户定义的对象，它限定或包含关于异步操作的信息。  

当传入的状态满足了条件, 才会向下执行 callback 回调函数. 这里的状态当然指的是 socket 的连接状态, 是未连接, 还是连接中, 还是连接成功.

State 状态对象 用来向回调方法传递状态信息.

还有 EndConnect 的函数原型:  

public void EndConnect(_IAsyncResult_ asyncResult);

那么我们先通过上面的知识, 改写上文中写的同步 socket 客户端.

因为我们用到了 _BeginConnect_ 这个异步 API, 这个 API 位于 System 命名空间下, 所以第一件事就是引入它的命名空间.

using _System_;

然后删除上文中的阻塞方法 socket._Connect_(iPEP);, 这里已经用不着了.

我们写上 public _IAsyncResult_ BeginConnect(_EndPoint_ remoteEP, _AsyncCallback_ callback, object state);

根据里面的 3 个参数一个一个的写好, 首先第一个是 IP 地址和端口, 我们的代码中有现成的, iPEP, 直接把这个填入第一个参数的位置, 然后看第二个, 上表中已经说了是个回调函数, 既然是个函数就要在代码中把函数写上  

```
 public void ConnectCallback(IAsyncResult ar)
{

}
```

再把 ConnectCallback 写在第二个参数的位置, 这里我们先不写这个回调函数的实现. 就写一个空架子. 然后再补.  

然后是一个 obj 类型的一个 state, 那么我们需要得到一个什么的 state 呢? 显然易见我们要知道 socket 的状态, 所以里面的参数直接就是代码中写好的 socket. 因为我们要知道的是 socket 的状态. 并且注意啊, 上面的参数介绍说这个对象会回传给回调函数.  

所以写好的代码如下:

```
pulic IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback
 ConnectCallback, socket);
```

好了,beginConnect 中的参数已经满足了, 但是回调函数里面还没有写, 那么这里应该怎么写呢?  


为了防止在连接服务器的过程中有一些难以预料的问题, 我们把代码放在 try catch 中. 因为我们不能保证每一次的连接都是一帆风顺的, 也许中间会出现一些网络波动或者服务器断电等一些问题.

```
 public void ConnectCallback(IAsyncResult ar)
    {
        try
        {
            Socket socketCb = ar.AsyncState as Socket;
            socketCb.EndConnect(ar );
            Debug.Log("连接服务器完成!");
        }
        catch (SocketException e)
        {
            Debug.Log("连接服务器失败!" + e);
        }
}
```

其实 _Socket_ socketCb = ar._AsyncState_ as _Socket__;_

中的 ar._AsyncState_ 某种意义上就是 _BeginConnect_ 回传回来的. 但是它又是 _Object_ 类型的, 所以代码中要转成 _socket_ 类型, 其实上文中定义的 _socket_ 与这个回调函数中的 _socketCb_ 某种意义上也可以认定它们是一个 _socket._

我们再来看下里面的逻辑,BeginConnect 通过 TCP 协议的 socket 开始连接到远方的服务器, 并启用一个 connectCallback 回调. 因为只有连接成功的时候才会去执行这个异步回调函数, 这里再多啰嗦几句.  

里面有一个 endConnect 方法, 那么这里的这个异步回调怎么解释呢?  

我们再举个例子解释一下同步回调  

比如你去商店买一支比较上档次的笔, 但是老板告诉你, 这个笔店里没有, 具体什么时候到货他也不知道, 但是你就是爱较真, 说我一定要买到这支笔, 你就在商店和老板耗着, 直到这支笔进货了, 你把笔买走. 那么这个就是同步回调.

换成程序语言来说就是如果这个回调函数没有返回数据, 线程就一直挂起, 直到有数据返回, 现场再重开.

然后异步回调

还是你, 还是那个商店, 你还要买一支笔, 仍旧是没货, 这里与同步回调不同的是, 当你听到老板说没货的时候, 你直接扭头就走, 然后你可以逛逛书店, 逛逛衣店, 然后过了几天你再来问, 假如老板说到货了了, 你就买, 假如老板仍旧说没货, 你还可以继续逛你的街.  

换成程序语言来说就是如果这个回调函数没有返回值, 整个程序不会因为这个没有获取到数据而挂起, 而是继续运行, 然后每隔一个固定的时间来查看是否有返回值, 如果没有, 对于程序来说不影响, 如果有返回, 就直接使用. 并且关掉连接 endConnect.

到这里, 仅仅是把一个客户端连接到服务器的功能改成了异步模式, 客户端还有接收功能, 这里同样要把阻塞的接收功能改成异步.

 int count = socket._Receive_(readBuff);

这里也许你会觉得疑惑, 为什么要用一个 int 来接收一个阻塞的方法, 需要说明的是, 这个阻塞的方法它的返回就是一个 int 类型的值, 当然, 在返回一个 int 类型的值的时候, 它已经把接收来的数据存到了字节数组 readBuff 中了.

上文中也说了, 每一个同步的 API 对应着两个异步的方法, 一个是 BeginXX, 一个是 EndXX, 那么这里同样有 BeginReceive() 和 EndReceive().

那么这里修改的与上篇文章中的阻塞方法实现起来有所不同, 当异步模式去连接服务器成功的时候我们就开始接收服务器的消息了:

所以我们把就收消息的方法写在 ConnectCallback 中.

我们来看 BeginReceive 的函数原型:

```
public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, object state);

public IAsyncResult BeginReceive(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);

public IAsyncResult BeginReceive(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, object state);

public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);

```

我们选用的是第四个函数原型, 我们还是来分析一下每一个参数的含义:

<table cellspacing="0"><tbody><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext; border-style: solid; border-width: 1px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">参数</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext windowtext windowtext currentcolor; border-style: solid solid solid none; border-width: 1px 1px 1px medium; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">说明</span></p></td></tr><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Buffer</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">一个字节数组, 用来存储服务器发过来的消息</span></p></td></tr><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Offset</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Buffer 中存储数据的位置的偏移量, 也就是说该从第几位开始存数据,</span></p></td></tr><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Size</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Buffer 的长度, 也代表着一次最多能接收服务器多少个字节</span></p></td></tr><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">socketFlags</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">socketFlags 值的按位组合, 这里设置为 0</span></p></td></tr><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Callback</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">一个异步回调函数</span></p></td></tr><tr><td width="115" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">State</span></p></td><td width="454" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">一个用户定义对象, 其中包含接收操作的相关信息, 当操作完成时, 此对象会传给 EndReceive 委托</span></p></td></tr></tbody></table>

其实这里的参数虽然多, 但是前面的 3 个仅仅是对于接收字节数组的一个约束, 后面的就比较眼熟了, 和上文中的 BeginAccept 一样.

对应着的 EndReceive 的原型如下, 它的返回值代表了收到的字节数.

Public int EndReceive (_IAsyncResult_ asyncResult);

就在客户端连接服务器的回调方法中使用接收数据的方法:

socketCb.BeginReceive(buffer, 0, 1024, 0, ReceiveCallBack, socket);

在定义 buffer 字节数组

 byte[] buffer = new byte[1024];

那么 Receive 的回调函数和上文中的 Connect 的回调函数一样的, 里面还是使用一个 try-catch 的方法体.

```
 public void ReceiveCallBack(IAsyncResult ar)
    {
        try
        {
            Socket socketCb = ar.AsyncState as Socket;
            int count = socketCb.EndReceive(ar);
            recvStr = System.Text.Encoding.Default.GetString(buffer, 0, count);
            socketCb.BeginReceive(buffer, 0, 1024, 0, ReceiveCallBack, socket);
        }
        catch (SocketException e)
        {
            Debug.Log("接收数据失败!" + e.Message);
        }
 }
```

也许你会对 ReceiveCallBack 里面还有一个 ReceiveCallBack 感到疑惑, 当我们客户端尝试去接收服务器消息的时候, 到了 ReceiveCallBack 回调函数里的时候就代表我们已经接收成功了, 那么我们当然还要继续接收服务器还要发送过来的消息, 程序仍然是等待着服务的消息.

图片来看的话就是:

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0fe435LTibKA3KP8kD13mJUdZiaTV70pTSn5AWoiaQSWB78iaJDC2C12IWQ/640?wx_fmt=png)

注意, 这里的 receiveCallback 中又回调了自身, 所以这里应该算一个递归, 这样写的原因是: 当接收消息完成后立马又开始下一轮的消息接收.

还有,Send 中的 Receive 已经没有用处了, 可以删除了. 但是 txtRev 没有地方来赋值, 所以我们在 Update 中对此赋值. 但是你也可以在 receivecallback 回调函数中赋值, 一样的.

```
 private void Update()
    {
        txtRev.text = recvStr;
}
```

Send

还有一个同步的阻塞方法, 就是 Send 方法, 虽然你会觉得, send 即使是阻塞, 同步的方法, 但是它速度很快呀, 一瞬间就发送完了呀, 但是你别忘了, 我们的传输协议是 TCP,TCP 协议是一个可靠的连接方式, 当它发送一个数据出去的时候, 一定要等到服务器的回应, 才能确定它发送成功了, 否则它会重新发送的, 那么我们想一个临界环境, 服务器就是有连接, 但是每次发消息都没有及时收到, 那么, 客户端会一直发, 那么就会一会卡一下, 一会卡一下, 前文也说了, 有时候你和你的对手较量, 同时放了必杀技, 但是有时候, 你就是败给了网速. 所以, 这个同步的阻塞的 Send, 我们一样不能用.

同样的, 同步的 Send. 对应着 BeginSend, 和 EndSend 两个方法, 首先来看 BeginSend 的函数原型:  


```
public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socket_flags, AsyncCallback callback, object state);

public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, object state);

 public IAsyncResult BeginSend(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);

public IAsyncResult BeginSend(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, out SocketError errorCode, AsyncCallback callback, object state);

```

  

这里我们采用第一个函数原型, 现在, 来解释一下每一个参数:

<table cellspacing="0"><tbody><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext; border-style: solid; border-width: 1px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">参数</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext windowtext windowtext currentcolor; border-style: solid solid solid none; border-width: 1px 1px 1px medium; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">说明</span></p></td></tr><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Buffer</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Byte 类型的数组, 包含发送的数据</span></p></td></tr><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Offset</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">从 buffer 中的 offset 位置开始发送</span></p></td></tr><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Size</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">要发送的字节的长度</span></p></td></tr><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">socketFlags</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">SocketFlags 值的按位组合, 这里设置为 0</span></p></td></tr><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">Callback</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">回调函数, 一个 AsyncCallback 委托</span></p></td></tr><tr><td width="144" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">State</span></p></td><td width="425" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">一个用户定义对象, 其中, 包含发送操作的相关信息, 当操作完成时, 此对象会被传递给 EndSend 委托</span></p></td></tr></tbody></table>

那么同样的还有一个 EndSend 函数原型如下:

 public int EndSend(_IAsyncResult_ result);

但是, 这里需要说明的是, Send 这个函数不是把数据发送到了服务器那里, 而是发送到了系统分配给 socket 的缓冲区中, 是的, 这里走到 send 的回调函数那里并不代表已经发送到服务器了, 而是在系统分配的缓冲区中.

在操作系统中, 每个 socket 都会有一个缓冲区, 就好比服务器可能要连接成千上万个客户端, 每一个客户端都是一个 socket 函数, 那么每一个 socket 都要分配一个缓冲区, 所以服务器的内存要大, 否则服务器就不堪重负, 卡到崩溃.

所以首先是发送到缓冲区, 然后下面的操作就是怎么从缓冲区发送到服务器, 这里就涉及到操作系统了, 我们这里不做过多的介绍. 操作系统中自己做的发送, 失败重传, 确认已发送等操作. 当然这个缓冲区也是有限的, 一旦存满了, 这个照样也会阻塞起来. 但是这里的阻塞与前文的阻塞不是指代一个东西, 前文阻塞是方法, 而这里是内存塞满造成的阻塞, 不要搞混淆.

那么到这里, 我们的第一个问题解决了, 把同步 socket 改成了异步 socket.

那么接下来, 我们将服务器的同步 socket 改成异步 socket, 并且可以连接多个客户端.

  

![](https://mmbiz.qpic.cn/mmbiz_gif/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0gaQUZadZZmNYMKCLcxbfgkTD9BjVic2meN0fn1zpbic8Ed2fDd8wPialw/640?wx_fmt=gif)

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0xdCia1SPFolCMuUECusKsibCzPop89EwTcwiaTbNc2wywUXpEQjuMjn0Q/640?wx_fmt=png)

异步模式的服务器

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0sEZr4OfYSiaicJ7relzafHEb9GVp3eWeC9l9ViaJNEaiaphVvQgqOjGXibA/640?wx_fmt=png)

 

如果是游戏服务器, 当玩家 A 放出一个必杀技, 在这个房间里的所有玩家都会看到 A 施放了一个必杀技, 那么其他玩家就开始躲, 玩家 A 就会看到各个玩家开始躲避了. 那么, 玩家所有的模型, 特效都是在客户端存在着的, 服务器只是发过来一条指令, 然后客户端生成这个特效, 仅此而已, 那么服务器充当的角色就很像一个” 广播” 的作用了.

服务器大概是怎么操作的呢? 首先, 它接收一条来自 A 的消息, 然后挨个发送给其他玩家, 所以其他玩家客户端就看到玩家 A 的动作了, 所以, 服务器就必须要有个列表用来存在所有连接着它的客户端, 那么要用什么来保存这个客户端呢? 这个客户端中得有一个客户端 socket, 还有它自身消息的字节数组. 那么我们可以选择用结构体或者类来做, 这里我使用类:  


```
 class ClientState
{
    public Socket  socket;
    public byte[] readBuff = new byte[1024];
}
```

  

然后用什么样的列表来存所有的客户端呢? 如果你对于数据结构有点了解, 存储一些相同类型的数据的话, 可以用数组, 列表, 字典等, 那么这里要选用什么数据结构合适呢?

我们来看, 一个客户端类中有客户端套接字与缓存数组, 从这方面来看, 似乎 List<T> 比较合适, 这个确实, 一个新的客户端连接进来了, 服务器直接把它 Add 到链表中, 但是我们知道, 服务连接的用户是十分庞大的, 上万个, 在容量有上万个的链表中查找某一个数据, 这个是十分不明智的做法, 具体为什么, 可以看这个文章: [数据结构与算法 (七)](http://mp.weixin.qq.com/s?__biz=Mzg4MDU1ODI2Mg==&mid=2247483889&idx=1&sn=12617d1b8b4ae5acef7b43ffcf8dc107&chksm=cf722828f805a13e8b2b5743d25b9d0c057dbb4c91bc455e68bfb72eee77d78544d4522ff162&scene=21#wechat_redirect)  


所以, 我们选用一种查找比较快速的数据结构: 字典

```
 static Dictionary<Socket, ClientState> clients = new Dictionary<Socket, ClientState>();
 
```

里面的结构如下:

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0ZeKKpEr4SwexibRVFHKHfX0ZHNcSQrO4PMg4OhFSSKWetkN60cy65mMsxZDYJ2gmgkTwtgWPk0Bew/640?wx_fmt=png)

  

那么接下来我们和上文一样, 把服务器中存在的同步阻塞方法, 改成异步方法. 服务器中除了与客户端同样的 Send,Receive 之外还有 Accept 方法, 同样的, 作为同步的 Accept 方法, 它也有两个异步方法, BeginAccept 和 EndAccept 方法.

BeginAccept 的函数原型如下:

```
  pulic IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);

  public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state);

  public IAsyncResult BeginAccept(AsyncCallback callback, object state);


```

  

我们这里用第三个函数原型, 来看里面的参数说明:

<table cellspacing="0"><tbody><tr><td width="139" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext; border-style: solid; border-width: 1px; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">参数</span></p></td><td width="429" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: windowtext windowtext windowtext currentcolor; border-style: solid solid solid none; border-width: 1px 1px 1px medium; --darkreader-inline-border-top:#8c8273; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">说明</span></p></td></tr><tr><td width="139" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">AsyncCallBack</span></p></td><td width="429" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">和前面的一样, 还是回调函数</span></p></td></tr><tr><td width="139" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:#8c8273;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">State</span></p></td><td width="429" valign="top" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-style="padding: 0px 7px; border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; --darkreader-inline-border-top:currentcolor; --darkreader-inline-border-right:#8c8273; --darkreader-inline-border-bottom:#8c8273; --darkreader-inline-border-left:currentcolor;"><p><span data-darkreader-inline-color="" data-darkmode-color-16576166479504="rgb(163, 163, 163)" data-darkmode-original-color-16576166479504="#fff|rgb(0, 0, 0)" data-style="font-family: 等线; color: rgb(0, 0, 0); font-size: 14px; --darkreader-inline-color:#e8e6e3;">表示状态信息, 填入已有的 socket 就可以</span></p></td></tr></tbody></table>

当程序执行到这里, 而不是卡在这里等待客户端来连接, 它可以继续做其他的事情, 当有客户端连接进来了之后, 开始调用回调函数, 在回调函数中, 还可以继续接收新的客户端来连接.

下面是 EndAccept 方法  

```
Public Socket EndAccept (
IAsyncResult asyncResult;
)


```

好了, 接下来就是要改造服务器端的代码了. 首先之前的因为阻塞所以使用的死循环, 这里要把它删除了, 然后同步的 Accept 方法与上文一样, 用 BeginAccept 改写:

 listenfd.BeginAccept(AcceptCallback, listenfd);

先将回调函数的架子写好:

```
public static void AcceptCallback(IAsyncResult ar)
        {
            try
            {


            }
            catch (SocketException e )
            {
                Console.WriteLine("接收客户端连接错误: " + e.Message);
            }

        }
```

那么要在这个空架子空写什么功能呢? 首先再来回顾一下回调函数的特性, 当满足了某个条件再来执行这个函数, 那么服务器如果接收到了客户端的连接, 并且已经连接成功了, 这个回调函数里面应当做些什么呢?

首先第一应该是接收它 socket 的一个状态

 Socket listenfd = ar._AsyncState_ as Socket;

其次, 连接好了之后就应该不在做 Accept 的操作了, 我们应该 EndAccept 了, 但是这个 EndAccept 的返回是个 socket 类型的, 但是我们又不能直接拿 listenfd 来接收, 因为它已经要接收委托函数中的 socket 的状态了. 所以我们应该再声明一个新的 socket 来接收.

 Socket clientfd = listenfd.EndAccept(ar);

那么, 请求连接的客户端存在哪里呢? 也许有点基础的会想到一个对象池, 但是这个我们这一步还没涉及到, 我们先用上文讲过的, 存在字典中.

那么, 我们要为每一个新连接进来的客户端分配一个 ClientState  , 然后将此客户端在服务器中实例的 socket 作为字典的 Key 值存入字典中.

```
 ClientState state = new ClientState();
                state.socket = clientfd;
                clients.Add(clientfd, state);


```

做好这一步, 就可以接收客户端发送过来的消息了, 当然了, 还是用异步方法, 本来同步方法是 Receive, 那么这里肯定是 BeginReceive 了.

 clientfd.BeginReceive(state.readBuff, 0, 1024, _SocketFlags_._None_, ReceiveCallback, state);

当然我们还是首先把它的回调函数先写好:

```
public static void ReceiveCallback(IAsyncResult ar)
        {
            try
            {
            }
            catch (SocketException e )
            {
                Console.WriteLine("接收客户端消息失败: " + e.Message);
            }
        }


```

当收到消息的时候, 通过 state 知道是否接收完毕, 然后决定是否要回调 receiveeCallback 函数. 但是, 注意啊, 这里和客户端不一样了, 这里的 Object 类型的是 ClientState , 那么为什么呢?, 因为有多个客户端, 这个 state 代表某个具体的客户端.

然后下面是继续 Accept 其他客户端的连接.

 listenfd.BeginAccept(AcceptCallback, listenfd);

接下来就是要完善 BeginReceive 的回调函数了. 当服务器确认和客户端建立起连接之后, 开始回调这个方法.

到这里需要说明的是, 当服务器确认收到了客户端的信息, 但是这个信息的长度小于等于 0 时, 表示 Socket 可以断开

```
public static void ReceiveCallback(IAsyncResult ar)

        {

            try

            {

                ClientState state = ar.AsyncState as ClientState;

                Socket clientfd = state.socket;

                int count = clientfd.EndReceive(ar);

                //客户端关闭

                if (count == 0)

                {

                    clientfd.Close();

                    clients.Remove(clientfd);

                    Console.WriteLine("Socket Closed ");

                    return;

                }

                string readStr = System.Text.Encoding.Default.GetString(state .readBuff, 0, count);

                byte[] sendBytes = System.Text.Encoding.Default.GetBytes(readStr);

                clientfd.Send(sendBytes);

                clientfd.BeginReceive(state.readBuff, 0, 1024, SocketFlags.None, ReceiveCallback, state);

            }

            catch (SocketException e )

            {

                Console.WriteLine("接收客户端消息失败: " + e.Message);

            }

        }


```

那么, 我们可以先测试一下

可以发现, 可以同时连接任意几个客户端, 每个客户端发送消息都能收到, 但是, 消息只能自身收到, 其他客户端却收不到, 因为我们还没有做广播的功能. 下篇文章加上广播的功能, A 客户端发送消息广播到所有连接上服务器的客户端.  

本案例的客户端与服务器源码下载方法: 公众号回复 服务器开发 即可.

…END…

![](https://mmbiz.qpic.cn/mmbiz_png/tXghtxYMW0aVnAhURoJcLfzJmw6zKeicKs7WatXaDnYsL3RzX8vicezeiaib9l1VgvPaD7CeQ9afI36YcFvlu1KEng/640?wx_fmt=png)