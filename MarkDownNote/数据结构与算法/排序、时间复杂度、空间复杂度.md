> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.daluozha.cn](https://www.daluozha.cn/2019/02/08/SAnComplexity/)

[](#排序 "排序")排序
--------------

<[https://www.runoob.com/w3cnote/ten-sorting-algorithm.html](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html) >

*   **插入排序**：_军训排队在已经排好了一个纵队的时候，有人要临时加入到这个队里来，于是教官大声喊道：“新来的，迅速找到你的位置，入队！” 于是新来的插入到这个队伍的合适位置中。_
    *   直接插入排序
        *   每趟将一个待排序的关键字按照其值的大小插入到已经排好的部分有序序列的适当位置上，直到所有待排关键字都被插入到有序序列中为止。
        *   时间复杂度最好 **O(n)**，最坏** O(n^2)**
        *   空间复杂度 **O(1)**
    *   折半插入排序
        *   折半查找法的一个基本条件是序列已经有序。
        *   时间复杂度最好 **O(nlog2n)**，最坏** O(n^2)**
        *   空间复杂度 **O(1)**
    *   希尔排序（缩小增量排序）
        *   <[https://www.runoob.com/w3cnote/shell-sort.html](https://www.runoob.com/w3cnote/shell-sort.html) >
            
        *   时间复杂度 **O(n^1.5) **或者** O(n^2)**
            
        *   空间复杂度 **O(1)**
            
*   **交换排序**：
    *   起泡排序：_军训刚刚开始，一群学生要排队，教官说：“你比你旁边的高，你俩换一下。怎么换完还比下一个高？继续换 ······” 最后这个同学将被换到最终合适的位置。_
        *   时间复杂度 **O(n^2)**
        *   空间复杂度 **O(1)**
    *   快速排序
        *   <[http://data.biancheng.net/view/117.html](http://data.biancheng.net/view/117.html) >
            
        *   时间复杂度最好 **O(nlog2n)**，最坏** O(n^2)**
            
        *   空间复杂度 **O(log2n)**，快速排序是递归进行的，递归需要栈的辅助，因为它需要的辅助空间比前面几类排序算法大。
            
*   **选择排序**：_军训排队的时候，教官说：“你们都站着别动，我看谁个子最小。” 然后教官选出个子最小的同学，说：“第一个位置是你的了，你和第一个同学换一下，剩下的同学我继续选。”_
    *   简单选择排序
        
        *   时间复杂度最好 **O(nlog2n)**，最坏** O(n^2)**
        *   空间复杂度 **O(1)**
    *   堆排序
        
*   **归并排序**：将两个或两个以上的有序序列合并成一个新的有序序列。
    *   二路归并排序：_继续排队，这次教官想了个特别的方法，他说：“你们每个人，先和旁边的人组成二人组，二人组内部先排好。” 看到大家排好了，继续说：“二人组和旁边的二人组继续组合成一个四人组，每个四人组内部排好，动作快！” 这样不停排下去，最后全部学生都归并到一个组中，同时也就排好序了。_
*   **基数排序**：最特别的一类，基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字，与前面的思想完全不同（前面都是要进行 “比较” 和”移动”这两个操作）。_例如，对一副去掉大小王的 52 张扑克牌进行基数排序，可以先按花色排序（如按红桃、黑桃、方片和梅花的顺序），这样就分成了 4 堆，然后每一堆再按照从 A 到 K 的顺序，排序使这副牌最终有序。_

[](#时间复杂度 "时间复杂度")时间复杂度
-----------------------

*   “大 O 表示法”：算法的渐进时间复杂度

**T(n) = O(f(n))**

其中，T(n) 就是代码的渐进时间复杂度，  
f(n) 是代码的执行次数，  
n 称为问题的规模，例如要处理的数组元素的个数为 n

*   常见的时间复杂度的代码：

O(1)

```
int x = 0 , y = 0;
int temp =x;
x = y;
y = temp;
```

O(n)

```
for(int i = 1;i <= n;i++){
  x++;
}
```

O(logn)

```
int i = 1;
while(i < n){
  i = i * 2;
}
```

O(nlogn)

```
for(int i = 0;i <= n;i++){
  int x = 1;
  while( x<n ){
    x = x * 2;
  }
}
```

O(n^2)

```
for(int i = 1;i <= n;i++){
  for(int j = 1;j <= n;j++){
    x++;
  }
}
```

O(nm)

```
for(int i = 1;i <= n;i++){
  for(int j = 1;j <= m;j++){
    x++;
  }
}
```

[](#空间复杂度 "空间复杂度")空间复杂度
-----------------------

*   空间复杂度：内存空间增长的趋势
*   常用的空间复杂度：

O(1)

```
int x = 0,y = 0;
x++;
y++;
```

O(n)

```
//数组
int[] newArray = new int[n];
for (int i = 0;i < n;i++){
  newArray[n] = i;
}
```

O(n^2)

```
//二维数组
```