> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/kVUIBfAeSbtGhvBQT9e8Eg)

### 验证码的作用

有效防止这种问题对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上是用验证码是现在很多网站通行的方式，利用比较简易的方式实现了这个功能。虽然登陆麻烦一点，但是对社区还来说这个功能还是很有必要，也很重要。

验证码一般是防止批量注册的，人眼看起来都费劲，何况是机器。二像百度贴吧未登录发贴要输入验证码大概是防止大规模匿名回帖的发生目前，不少网站为了防止用户利用机器人自动注册、登录、灌水，都采用了验证码技术。所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片， 图片里加上一些干扰象素（防止 OCR），由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。

### 具体实现

封装的 helper 类，拿来用就行

```
/// <summary>    /// 生成验证码的类    /// </summary>    public class ValidateCode    {        /// <summary>        /// 生成验证码        /// </summary>        /// <param >指定验证码的长度</param>        /// <returns></returns>        public string CreateValidateCode(int length)        {            var codeSerial = "2,3,4,5,6,7,8,a,b,c,d,e,f,h,i,j,k,m,n,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,U,V,W,X,Y,Z";//自定义随机码字符串序列(使用逗号分隔)            string[] arr = codeSerial.Split(',');            var validateNumberStr = "";//验证码            int randValue = -1;//随机数            Random rand = new Random(unchecked((int)DateTime.Now.Ticks));            //生成验证码            for (int i = 0; i < length; i++)            {                randValue = rand.Next(0, arr.Length - 1);                validateNumberStr += arr[randValue].ToString();            }            return validateNumberStr;        }        /// <summary>        /// 创建验证码的图片        /// </summary>        /// <param >验证码</param>        public byte[] CreateValidateGraphic(string validateCode)        {            Bitmap image = CreateImageCode(validateCode);            //保存图片数据            MemoryStream stream = new MemoryStream();            image.Save(stream, ImageFormat.Jpeg);            //输出图片流            return stream.ToArray();        }        /// <summary>        /// 生成校验码图片        /// </summary>        /// <param ></param>        /// <returns></returns>        public Bitmap CreateImageCode(string code)        {            int Length = code.Length;//验证码长度            int fSize = 40;//验证码字体大小            int FontSize = 40;            int Padding = 2;//边框补            int fWidth = fSize + Padding;            int imageWidth = (int)(code.Length * fWidth) + 4 + Padding * 2;            int imageHeight = fSize * 2 + Padding;            System.Drawing.Bitmap image = new System.Drawing.Bitmap(imageWidth, imageHeight);            Graphics g = Graphics.FromImage(image);            Color BackgroundColor = Color.White;//自定义背景颜色            Color ChaosColor = Color.LightGray;//噪点颜色            Color[] Colors = { Color.Black, Color.Red, Color.DarkBlue, Color.Green, Color.Orange, Color.Brown, Color.DarkCyan, Color.Purple };//自定义随机颜色数组            string[] Fonts = { "Arial", "Georgia" };//自定义字体数组            bool chaos = true;//是否输出噪点            g.Clear(BackgroundColor);            Random rand = new Random();            //给背景添加随机生成的燥点            if (chaos)            {                Pen pen = new Pen(ChaosColor, 0);                int c = Length * 10;                for (int i = 0; i < c; i++)                {                    int x = rand.Next(image.Width);                    int y = rand.Next(image.Height);                    g.DrawRectangle(pen, x, y, 1, 1);                }            }            int left = 0, top = 0, top1 = 1, top2 = 1;            int n1 = (imageHeight - FontSize - Padding * 2);            int n2 = n1 / 4;            top1 = n2;            top2 = n2 * 2;            Font f;            Brush b;            int cindex, findex;            //随机字体和颜色的验证码字符            for (int i = 0; i < code.Length; i++)            {                cindex = rand.Next(Colors.Length - 1);                findex = rand.Next(Fonts.Length - 1);                f = new System.Drawing.Font(Fonts[findex], fSize, System.Drawing.FontStyle.Bold);                b = new System.Drawing.SolidBrush(Colors[cindex]);                if (i % 2 == 1)                {                    top = top2;                }                else                {                    top = top1;                }                left = i * fWidth;                g.DrawString(code.Substring(i, 1), f, b, left, top);            }            //画一个边框 边框颜色为Color.Gainsboro            g.DrawRectangle(new Pen(Color.Gainsboro, 0), 0, 0, image.Width - 1, image.Height - 1);            g.Dispose();            //产生波形（Add By 51aspx.com）            image = TwistImage(image, true, 8, 4);            return image;        }        private const double PI = 3.1415926535897932384626433832795;        private const double PI2 = 6.283185307179586476925286766559;        /// <summary>        /// 正弦曲线Wave扭曲图片（Edit By 51aspx.com）        /// </summary>        /// <param >波形的幅度倍数，越大扭曲的程度越高，一般为3</param>        /// <param >波形的起始相位，取值区间[0-2*PI)</param>        /// <returns></returns>        public System.Drawing.Bitmap TwistImage(Bitmap srcBmp, bool bXDir, double dMultValue, double dPhase)        {            System.Drawing.Bitmap destBmp = new Bitmap(srcBmp.Width, srcBmp.Height);            // 将位图背景填充为白色            System.Drawing.Graphics graph = System.Drawing.Graphics.FromImage(destBmp);            graph.FillRectangle(new SolidBrush(System.Drawing.Color.White), 0, 0, destBmp.Width, destBmp.Height);            graph.Dispose();            double dBaseAxisLen = bXDir ? (double)destBmp.Height : (double)destBmp.Width;            for (int i = 0; i < destBmp.Width; i++)            {                for (int j = 0; j < destBmp.Height; j++)                {                    double dx = 0;                    dx = bXDir ? (PI2 * (double)j) / dBaseAxisLen : (PI2 * (double)i) / dBaseAxisLen;                    dx += dPhase;                    double dy = Math.Sin(dx);                    // 取得当前点的颜色                    int nOldX = 0, nOldY = 0;                    nOldX = bXDir ? i + (int)(dy * dMultValue) : i;                    nOldY = bXDir ? j : j + (int)(dy * dMultValue);                    System.Drawing.Color color = srcBmp.GetPixel(i, j);                    if (nOldX >= 0 && nOldX < destBmp.Width                     && nOldY >= 0 && nOldY < destBmp.Height)                    {                        destBmp.SetPixel(nOldX, nOldY, color);                    }                }            }            return destBmp;        }    }
```