> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/ni9i0jc3EuQfBNojnlZH-g)

在. NET 中，`lock`语句用于确保一个代码块在任何时候只被一个线程访问。为了使用`lock`，你需要提供一个对象作为锁。这个对象被称为 “锁对象” 或“监视器对象”。当线程尝试进入`lock`块时，它会尝试获取该对象的锁。如果锁已经被其他线程持有，则该线程将被阻塞，直到锁被释放。

那么，问题是：在. NET 中，`string`类型可以作为`lock`的锁对象吗？

答案是：**可以**，但通常不建议这么做。

### 为什么可以？

在. NET 中，所有的对象都继承自`System.Object`，而`System.Object`类有一个名为`Monitor`的静态类，该类提供了`Enter`, `Exit`, 和 `TryEnter`等方法，这些方法用于实现`lock`语句的底层机制。由于`string`类型也继承自`System.Object`，因此它可以被用作锁对象。

### 为什么不建议？

尽管技术上可行，但使用`string`作为锁对象有几个潜在的问题：

1.  **不可变性**：`string`类型在. NET 中是不可变的。这意味着每次你对`string`对象进行修改（如拼接、替换等操作）时，都会创建一个新的`string`对象。如果你用这样的`string`作为锁对象，可能会无意中在不同的`string`实例上锁定，这可能导致意外的并发问题。
    
2.  **不透明的锁定**：使用`string`作为锁对象可能导致代码的其他部分不清楚哪个线程正在使用该锁，因为`string`可能会被用作其他目的。这降低了代码的可读性和可维护性。
    
3.  **潜在的冲突**：如果你的应用程序中的不同部分都使用相同的`string`常量作为锁对象，那么这些部分可能会意外地彼此阻塞，导致死锁或性能问题。
    

### 更好的做法

为了避免上述问题，最佳做法是使用私有的、只读的对象实例作为锁对象。这样，你可以确保锁的使用是明确和可控的。例如，你可以定义一个私有的`object`字段来作为锁对象：

```
private readonly object _lockObject = new object();public void SomeMethod(){    lock (_lockObject)    {        // 访问或修改共享资源的代码    }}
```

通过这种方式，你可以确保锁的使用是明确的，并且只在需要时发生。此外，由于`_lockObject`是私有的，因此它不太可能与其他代码中的锁对象冲突。

### 结论

虽然技术上可以使用`string`作为`lock`的锁对象，但出于上述原因，通常不建议这么做。相反，你应该使用专门的、私有的对象实例来作为锁对象，以确保并发控制的安全性和可维护性。