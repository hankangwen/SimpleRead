> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/wbf4oCVeQbufed8AVQIOQw)

### **1. 值类型与内存布局**

值类型：`struct`是 C# 中的一种值类型，这意味着它的实例直接包含其数据成员（字段）的值。当一个`struct`实例被创建时，其内存会在栈上分配（对于局部变量和方法参数）或作为其宿主对象的一部分在堆上分配（对于类的实例字段）。值类型的复制是浅拷贝，即复制整个值，而不是引用。

内存布局：`struct`的内存布局紧密且连续，其大小等于所有字段大小之和，且通常没有额外的开销。编译器会根据字段类型和大小自动优化布局。对于嵌套`struct`，其内部结构也会被扁平化并一起存储在同一块内存中。

### **2. 初始化**

默认初始化：未显式初始化的`struct`实例会由编译器自动进行字段级别的默认初始化。数值类型字段会被初始化为 0（或其对应的零值），引用类型字段（如`string`或其他`class`类型）会被初始化为`null`。

构造函数：`struct`可以拥有构造函数，用于在实例创建时进行自定义初始化。构造函数必须为实例的所有字段提供初始值。由于`struct`不允许存在无参构造函数，因此在声明变量时不指定初始值时，需要使用默认值初始化语法：

```
MyStruct s = new MyStruct();  // 错误：无参构造函数不允许在struct中

// 正确的初始化方式
MyStruct s = new MyStruct(1, "value");  // 使用带参数的构造函数
MyStruct s = default;  // 使用默认值初始化
```

### **3. 不可变性**

尽管`struct`可以包含可写的字段和属性，但由于它们是值类型，每次赋值操作都会创建一个新的副本。为了保持数据一致性并避免意外的副作用，通常建议将`struct`设计为不可变（只读）：

```
public struct Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
}

// 使用
Point p = new Point(10, 20);
```

### **4. 隐式装箱与拆箱**

由于`struct`是值类型，它们不能直接赋值给引用类型变量。在需要将`struct`转换为引用类型（如`object`）时，会发生装箱操作，即将`struct`实例封装到一个引用类型对象中。反之，从引用类型到`struct`类型的转换称为拆箱。

```
MyStruct s = new MyStruct(1, "value");
object obj = s;  // 装箱：将s装箱为object
MyStruct s2 = (MyStruct)obj;  // 拆箱：从obj恢复为MyStruct
```

装箱和拆箱操作有一定的性能开销，应尽量避免在性能敏感的代码中频繁使用。

### **5. 使用注意事项**

*   **避免过大**：由于`struct`实例存储在栈上（或作为其他对象的一部分），过大的`struct`可能导致栈溢出。一般来说，如果`struct`包含大量数据或其大小超过 16 字节，应考虑使用`class`替代。
    
*   **避免不必要的复制**：`struct`的赋值、作为参数传递以及作为返回值时都会创建副本。在需要频繁操作或传递大型`struct`时，应考虑使用`ref`或`in`修饰符减少不必要的复制。
    
*   **避免在集合中使用**：除非有特殊需求，否则通常不推荐将`struct`作为集合（如`List<T>`）的元素类型，因为集合操作（如添加、删除、索引访问）会导致大量的复制操作。
    

总结起来，C# 中的`struct`适用于表示小型、轻量级的数据结构，尤其是在需要高效内存管理和避免对象开销的场景中。理解其作为值类型的行为特点和内存管理特性，有助于正确、高效地使用`struct`。